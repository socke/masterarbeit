%%$Id$
\setchapterpreamble[u]{%
\dictum[Anton Bruckner]{Wer hohe Türme bauen will, muß lange beim Fundament verweilen. \dots}}

\chapter{Implementierung und Komponententest}

Dieses Kapitel beschreibt die Implementierungsphase. Die Implementierung teilt sich in drei Teilaufgaben. Die Erstellung des Importers, die Erstellung der View und die des Web Services. 

\section{Importer} \index{Importer}

Die Implementierung des Importers ist eines der größten Teile der Implementierungsphase. Einige Ansätze konnten aus dem Prototyp entnommen werden. Ursprünglich war geplant, die Datenbankstraktionsklassen \enquote{DB\_QueryTool} der PEAR Bibliothek für den Importer zu benutzen. Jede Tabelle kann so als Klasse abgebildet werden und sämtliche Operationen finden mit Hilfe von Methodenaufrufen statt. Mehr Informationen zum \enquote{DB\_QueryTool} beinhaltet das Kapitel \ref{anhang:PEAR} im Anhang. 
Da der Importer über XML-Files konfiguriert werden muss, stellte sich die Umsetzung als schwierig dar. Die Konfiguration der Datenbankzugänge als auch die Konfiguration der zu importierenden Tabellen muss aus dem XML-File gelesen und automatisch in SQL umgesetzt werden. Um dies zu realisieren, müssten die konkreten Datenbankklassen dynamisch zur Laufzeit erstellt werden, nämlich genau dann, wenn das XML-File zum Import ausgelesen wird. Dies ist möglich, jedoch sehr zeitaufwendig. Daher wurde eine QueryHelper-Klasse erstellt, die für die Erstellung der SQL-Queries zuständig ist. Dieser Klasse wird die entsprechende Tabelle, die zu importierende Attribute, die möglichen WHERE-Bedingungen und eventuelle IN-Mengenabfragen als Array übergeben. Die Rückgabe ist nun das fertige SQL-Statement als String, welches nur noch ausgeführt werden muss. 
Der \enquote{QueryHelper} verfügt auch über eine Methode, welche die Tabellen automatisch anlegt, sofern diese nicht schon bestehen. Auch hierfür wird das XML-File ausgelesen und die Tabelle entsprechend der Einstellungen im XML-File angelegt. 

\section{View} \index{View}

Die View greift in die vorhandene Ansicht des Change und Incident Managements ein. Hierfür wurden die Dateien \enquote{im\_newIncident.php} und \enquote{cm\_newChange.php} angepasst. Diese wurden um die Funktionalität erweitert, dass nun die Tickets nach Eingabe einer Ticketnummer angezeigt werden und in einer Liste ausgewählt werden können. Es können mehrere Tickets einem Eintrag hinzugefügt werden. 
Diese Ticketansicht wurde mit Hilfe von AJAX erstellt. Mehr Informationen zur Erstellung von AJAX-Anwendungen beinhaltet das Kapitel \ref{anhang:ajax} im Anhang.
Die ChaMPS-Einträge werden über den Importer automatisch in die AiO Change und Incident Management Übersicht eingefügt. Es sind keine Anpassungen in der vorhandenen Ansicht hierfür nötig. 

\section{Web Service} \index{Web Service}

Die Erstellung des Web Services war der dritte Teil der Implementierungsphase. Auch hier gab es einen kleinen Vorabtest. Für die Realisierung wurde die PEAR-Klasse \enquote{SOAP\_Server} benutzt. 
Die Erstellung eines Web Services beschreibt Kapitel \ref{anh:webservice} im Anhang. 

\section{Einbindung in AiO} \index{AiO}

Zur Einbindung in AiO mussten einige Anpassungen vorgenommen werden. Bereits erwähnt wurden die Anpassungen in den Dateien \textbf{im\_newIncident.php} und \textbf{cm\_newChange.php}, damit die Daten der importierten Tickets nun auch angezeigt und Changes oder Incidents zugewiesen werden können. 
Weiterhin mussten für die Verknüpfung der Tickets mit den Changes und Incidents zwei Tabellen mit einer n:m Beziehung erstellt werden. Diese Tabellen beinhaltet zum einen die Ticketnummer und zum anderen die ID des entsprechenden Incident- oder Changeeintrages. Hiermit kann gewährleistet werden, dass ein Eintrag mehrere Tickets zugewiesen hat. Mehr Informationen im Anhang in Kapitel \ref{anh:technischeshandbuch}. 

\section{Unit Tests} \index{Unit Tests} \index{PHPUnit}

Während der Implementierung des Systems wurden Unittests durchgeführt. Da der vorhandene Server nur über PHP4 verfügt, musste PHPUnit für PHP4 benutzt werden. Die ältere Version von PHPUnit wurde dann auf dem Server installiert. 

\subsection{Klasse unter Test}

Representativ für das Testing mit PHPUnit soll hier eine Klasse abgetestet werden. Listing \ref{lst:PHPUnitQueryHelper} zeigt die QueryHelper-Klasse, welche für die Erstellung der SQL-Queries zuständig ist.  
\begin{lstlisting}[caption=QueryHelper Class, language=PHP,label=lst:PHPUnitQueryHelper]
<?php
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/**
* Class is a query helper class an can create queries
* by the given Attributes, Table and Where-Claus Names
*
* PHP versions 4 and 5
*
* @package    View
* @author     Stefan Sobek <stefan@sobek.info>
* @copyright  2007 Vodafone D2 GmbH - TBAN
* @version    CVS: $Id$
*/
class QueryHelper {
    /** 
    * Function creates a SELECT-query by the given attributes.
    * Attributes can be an array or a skalar.
    * @param mixed $arrayIn 		The IN-query part with name and vals
    * @param mixed $arrayAttributes The Attributes to select from the db
    * @param mixed $arrayTables     The Tables to select the attributes from
    * @param mixed $arrayWhere      The array which contains the where clauses.
	*                                  in the way like this: $arrayWhere[] = "attribut = wert";
	*                                  $arrayWhere[] = "attribut2 > wert2";
	*                                  this will create a sql statement like:
	*                                  ... WHERE attribut = wert AND attribut2 > wert2
    * @return The query to execute
    */
    function createQuery($arrayAttributes = '', $arrayTables = '', $arrayWhere = '', $arrayIn = '') {
   
     if (is_array($arrayAttributes)) {
	       $queryAttributes = implode(",",$arrayAttributes);
	    } else {
	       $queryAttributes = $arrayAttributes;
	    }
	    $query = "SELECT ".$queryAttributes;
	 
	    if (is_array($arrayTables)) {
	       $queryTables = implode(",",$arrayTables);
	    } else {
	       $queryTables = $arrayTables;
	    }
	    $query.= " FROM ".$queryTables;
	 
	    if (is_array($arrayWhere)) {
	       // iterate over queries
			$query.= " WHERE ";
			for ($i = 0; $i < sizeof($arrayWhere); $i++) {
				if ($i == 0) {
					$query.= $arrayWhere[$i];
				} else {
					$query.= " AND ". $arrayWhere[$i];
				}		
			}
			if ($arrayIn != '') {
				$query.= " AND ".$arrayIn['name']." IN (".$arrayIn['vals'].")";
			} 
	    } else if ($arrayWhere != '') {
			$query.= " WHERE ". $arrayWhere;
			if ($arrayIn != '') {
				$query.= " AND ".$arrayIn['name']." IN (".$arrayIn['vals'].")";
			}		
		} else {
		   if ($arrayIn != '') {
				$query.= " WHERE ".$arrayIn['name']." IN (".$arrayIn['vals'].")";
			}	
		}
     return $query;
   }
    
    /**
	* Function creates a sql-query which creates a new table depending
	* on the params given and returns this query.
	*
	* Function will create a query like:
	* CREATE TABLE IF NOT EXISTS `test` (
	*	`id` VARCHAR( 255 ) NULL ,
	*	`txt1` TEXT NULL ,
	*	`int1` INT NULL ,
	*	`txt2` TEXT NULL ,
	*	`vc` VARCHAR( 255 ) NULL
	*	)
	*
	* when an an $attributes array like the following was given:
	*
	* $attributes[0]['name'] = "id";
	* $attributes[0]['type'] = "VARCHAR";
	* $attributes[0]['length'] = "255";
	* $attributes[1]['name'] = "txt1";
	* $attributes[1]['type'] = "TEXT";
	* $attributes[1]['length'] = "";	
	* $attributes[2]['name'] = "int1";
	* $attributes[2]['type'] = "INT";
	* $attributes[2]['length'] = "";	
	* $attributes[3]['name'] = "txt2";
	* $attributes[3]['type'] = "TEXT";
	* $attributes[3]['length'] = "";	
 	* $attributes[4]['name'] = "txt1";
	* $attributes[4]['type'] = "VARCHAR";
	* $attributes[4]['length'] = "255";	
	*
	* NOTE: This ist only tested for MySQL Databases!!!
	*
	* @param string $tablename  The name of the table to create
	* @param mixed  $attributes The array with the attributes to create
	* @return string The creation query
	*/
	function createNewTableQuery($tablename = '', $attributes = '') {
	
		if ($tablename != '' && $attributes != '') {
			$query = "CREATE TABLE IF NOT EXISTS ".$tablename." ( ";
			foreach ($attributes as $key => $val) {
				if ($val['pk'] == 1) $pk = $val['name'];
				$query.= " ".$val['name']." ".$val['type'];
				if ($val['length'] != '') {
					$query.= " ( ".$val['length']." ) ";
				}
				//if ($val['pk'] == 1) {
				//	$query.= ",";
				//} else {
					$query.= " DEFAULT NULL ,";
				//}
			}
			if (isset($pk)) {
				$query.= " PRIMARY KEY (".$pk.")";
			} else {
				// delete last comma
				$query = substr($query,0,strlen($query)-1);
				
			}
			$query .= ")";
		}
		return $query;
	}
}

?>
\end{lstlisting} 

\subsection{Testklasse}

Das Listing \ref{lst:PHPUnitQueryHelperTest} zeigt den Unittest der Klasse aus Listing \ref{lst:PHPUnitQueryHelper}.

\begin{lstlisting}[caption=PHPUnit Test QueryHelperTest Class, language=PHP,label=lst:PHPUnitQueryHelperTest]
<?php
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/**
* This file contains the PHPUnit test class for the QueryHelperTest class  
*
* PHP versions 4 and 5 - PHPUnit for PHP4
*
* @package    Importer
* @author     Stefan Sobek <stefan@sobek.info>
* @copyright  2007 Vodafone D2 GmbH - TBAN
* @version    CVS: $Id$
*/

/**
* include TestCase class
*/
require_once 'PHPUnit/TestCase.php';

/**
* include TableFactory Class
*/
require_once '../classes/QueryHelper.class.php';

/**
* include parser class
*/
require_once '../classes/XmlParser.class.php';

/**
* The class is the test class for the QueryHelper class
* 
* @package    Web_Service
* @author     Stefan Sobek <stefan@sobek.info>
*/
class QueryHelperTest extends PHPUnit_TestCase {
	
	/**
	* The QueryHelper class
	*/
	var $queryHelper; 
	
	/**
	* The attributes of the table
	*/
	var $attributes;
	
	/**
	* The tables of the database
	*/
	var $tables;
	 
    function setUp() {
		$this->queryHelper = new QueryHelper();
		$this->attributes = array('id','name','surname');
		$this->tables = array('name' => 'customer');	
	}
    /**
	* Method tests a simple query with only select and from
	*/
    function testCreateQuerySimple() {
    	$query = $this->queryHelper->createQuery($this->attributes, $this->tables);
		$this->assertEquals("SELECT id,name,surname FROM customer", $query);
    }
	/**
	* Method tests a simple query with "WITH" clause
	*/
	function testCreateQueryWithWhere() {
		$where = "name = 'stevo'";
    	$query = $this->queryHelper->createQuery($this->attributes, $this->tables, $where);
		$this->assertEquals("SELECT id,name,surname FROM customer WHERE name = 'stevo'", $query);
	}
	/**
	* Method tests a simple query with "IN" clause
	*/	
	function testCreateQueryWithIn() {
		$where = "";
		$in = array("name" => "abteilung", "vals" => "'abt1','abt2'");
    	$query = $this->queryHelper->createQuery($this->attributes, $this->tables, $where, $in);
		$this->assertEquals("SELECT id,name,surname FROM customer WHERE abteilung IN ('abt1','abt2')", $query);
	}	
	/**
	* Method tests a simple query with "IN" and "WHERE" clause
	*/	
	function testCreateQueryWithInAndWhereArray() {
		$where = array("name = 'stevo'", "surname = 'peterli'");
		$in = array("name" => "abteilung", "vals" => "'abt1','abt2'");
    	$query = $this->queryHelper->createQuery($this->attributes, $this->tables, $where, $in);
		$this->assertEquals("SELECT id,name,surname FROM customer WHERE name = 'stevo' AND surname = 'peterli' AND abteilung IN ('abt1','abt2')", $query);
	}			
	/**
	* Method parses a config file and creates a query from this config file
	*/
	function testCreateQueryFromXML() {
		$tablesttwos = XmLParser::parse("../config/tablesttwos.xml");
		$where = '';
		$atts = array();
		foreach ($tablesttwos['root']['importer']['table'][0]['attribute'] as $val) {
			$atts[] = $val['name'];
		}
		$query = $this->queryHelper->createQuery($atts, $tablesttwos['root']['importer']['table'][0]['name'], $where, $tablesttwos['root']['importer']['table'][0]['in']);
		$this->assertEquals("SELECT...", $query);
	}		
	
}
?>
\end{lstlisting}  

\subsection{Test Suite}

Um nun die Tests auszuführen muss eine TestSuite angelegt werden. Listing \ref{lst:PHPUnitTestSuite} zeigt, wie nun die erstellten Tests eingebunden werden können. Das Beispiel zeigt die Test aus dem Importer-Paket.

\begin{lstlisting}[caption=PHPUnit TestSuite, language=PHP,label=lst:PHPUnitTestSuite]
<?php
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/**
* This file will create a testsuite with all Unit-Tests
* of the import-modul
* Add here new Testclasses to get executed  
*
* PHP versions 4 and 5
*
* @package    Web_Service
* @author     Stefan Sobek <stefan@sobek.info>
* @copyright  2007 Vodafone D2 GmbH - TBAN
* @version    CVS: $Id$
*/

/**
* Include PHPUnit Testclass
*/
require_once 'PHPUnit.php';

/**
* Include here the classes under test!!! 
*/
require_once 'TableFactoryTest.class.php';
require_once 'XmlParserTest.class.php';
require_once 'QueryHelperTest.class.php';

/**
* Add a new line for a new Test. Will be executed then.
*/
$suite[]  = new PHPUnit_TestSuite('TableFactoryTest');
$suite[]  = new PHPUnit_TestSuite('XmlParserTest');
$suite[]  = new PHPUnit_TestSuite('QueryHelperTest');

/**
* NO CHANGES DOWN HERE - code will execute the tests
*/
print "<pre>";
foreach ($suite as $val) {
   $result = PHPUnit::run($val);
   print $result->toString()."\n";
}
print "</pre>";
?>

\end{lstlisting}

Die TestSuite-Datei kann dann einfach über einen Webbrowser aufgerufen werden. Wahlweise lässt sich die TestSuite auch automatisiert, z.B. via CronJob ausführen. 

Mehr Informationen über PHPUnit-Tests sowie eine Installationsanweisung beinhaltet Kapitel \ref{anh:phpunit} im Anhang.

\section{Komponententests} \index{Komponententests}


