%% $Id: pear.tex 10 2007-05-15 08:52:47Z stefan $
%% Anhang - PEAR 

\chapter{PEAR}\label{anhang:PEAR} \index{PEAR}

Der Zweck dieses Kapitels ist die kurze Erläuterung von PEAR, sowie eine kurze Einführung. Es werden nur die in diesem Projekt eingesetzten Pakete und Klassen aus der Bibliothek erklärt. 

\section{Was ist PEAR?}

PEAR bedeutet \enquote{PHP Extension and Application Repository} und ist eine Sammlung von Modulen und Klassen für die Programmiersprache PHP. 

PEAR wurde zu dem Zweck erschaffen, folgende Dinge zu unterstützen \citep[vgl.][]{pear}:

\begin{itemize}
	\item Eine strukturierte Open-Source Bibliothek für PHP Benutzer
	\item Ein System für die Weitergabe von Code und für die Wartung von Softwarepaketen
	\item Einen Standardstil für PHP-Code. 
\end{itemize}

PEAR erleichtert nicht nur die Arbeit des PHP-Entwicklers, sondern bietet darüberhinaus noch die Möglichkeit strukturiert und objektorientiert zu entwickeln. 

Dies ist auch der Grund, wieso in diesem Projekt der größte Teil mit Hilfe der PEAR-Bibliothek entwickelt wird. 

\section{Nützliche Pakete}

\subsection{PEAR::DB} \index{PEAR!DB}

Das PEAR::DB-Paket ist wohl eines der bekanntesten Pakete. Es ist ein Datenbankabstraktionslayer. Das bedeutet, dass Anwendungen unabhängig von der benutzten Datenbank implementiert werden können. Die Handhabung ist auf abstrakter Ebene völlig identisch. 

Da PHP5 in diesem Projekt zur Zeit noch nicht zur Verfügung steht, kommt das PEAR::DB Paket zum Einsatz. Das PEAR-DB Paket unterstützt folgende Datenbanken:

\begin{itemize}
	\item dBase
	\item FrontBase
	\item InterBase
	\item Informix
	\item Mini SQL
	\item Microsoft SQL Server
	\item MySQL < Version 4
	\item MySQL > Version 4
	\item Oracle 7/8/9
	\item ODBC
	\item PostgreSQL
	\item Sqlite
	\item SyBase
\end{itemize}

Wie eine Beispieldatenbankverbindung mit PEAR aussieht, das zeigt Listing \ref{lst:PHP_Connection_Test}.

\begin{lstlisting}[caption=PHP Connection Test, language=PHP, label=lst:PHP_Connection_Test]
<?php
//DB-Modul laden
require_once "DB.php";

//setzen der variablen für connect
$dsn = array(
    'phptype'  => 'sybase',
    'username' => 'ssobek',
    'password' => '12345678',
    'hostspec' => 'ttwostst_hs',
    'database' => 'ARSystem',
);

//connect
$db =& DB::connect($dsn);
if (DB::isError($db)) {
    die($db->getMessage());
}

$query = "select GT_Ticketnummer, AR_ErstellungsDatum, GT_Buchungsdatum, GP_Priorit_t from MMO_TT_ATT_Bearbeiter_Ticket";

$res =& $db->limitQuery($query, 0, 10); 

if (DB::isError($res)) {
    die($res->getMessage());
}

echo '<table border="1">'; 
   echo '<tr>'; 
   echo "<td style=\"background-color:#CCCCCC\">GT_Ticketnummer</td>"; 
   echo "<td style=\"background-color:#CCCCCC\">AR_ErstellungsDatum</td>"; 
   echo "<td style=\"background-color:#CCCCCC\">GT_Buchungsdatum</td>";
   echo "<td style=\"background-color:#CCCCCC\">GP_Priorit_t</td>";
   
   echo '</tr>';
while ($data = $res->fetchRow(DB_FETCHMODE_ASSOC)) 
{    
   echo '<tr>'; 
   echo "<td>$data[GT_Ticketnummer]</td>"; 
   echo "<td>$data[AR_ErstellungsDatum]</td>";
   echo "<td>$data[GT_Buchungsdatum]</td>"; 
   echo "<td>$data[GP_Priorit_t]</td>";
   echo '</tr>';
} 
echo '</table>'; 
$db->disconnect();
?>
\end{lstlisting}

Erklärung des Quellcodes:

\begin{description}
	\item[Zeile 57] Hierdurch wird das PEAR-Paket eingebunden. Ist PEAR auf dem Server richtig installiert, muss hier keine Pfadangabe erfolgen. 
	\item[Zeile 60-66] Hier werden die Verbindungsparameter angegeben. Dies kann entweder per Assoziativem Array erfolgen, oder alternativ direkt der connect-Methode übergeben werden.
	\item[Zeile 69] Mit der Connect-Methode wird die Verbindung mit der Datenbank aufgebaut. Dies ist völlig datenbankunabhängig.
	\item[Zeile 70-72] Dies ist eine PEAR-typische Fehlerüberprüfung. PEAR liefert immer bei aufgetretenem Fehler ein PEAR::Error Objekt zurück.
	\item[Zeile 74] Der Query wird festgelegt.
	\item[Zeile 76] Der Query wird ausgeführt.
	\item[Zeile 90-98] Innerhalb einer While-Schleife wird nun das Datenbankergebnis durchlaufen. Die Variable \$data beinhaltet nun ein Assoziatives Array. Festgelegt werden kann das durch eine Konstante. In diesem Fall wurde die Konstante DB\_FETCHMODE\_ASSOC benutzt. Weiter Konstanten sind:
	
\begin{description}
	\item[DB\_FETCHMODE\_OBJECT] für die Rückgabe eines Objektes
	\item[DB\_FETCHMODE\_FLIPPED] vertauscht Reihen und Spalten
\end{description}
    
\end{description}

Für mehr Informationen über PEAR::DB \citep[vgl.][]{peardb}

%subsection 

\subsection{PEAR::Config} \index{PEAR!Config}

Das Config-Paket der PEAR Bibliothek ist ein sehr nützliches Werkzeug zum Erstellen, Einlesen und Manipulieren von Configurationsfiles. Config kann mit mehreren Arten von Konfigurationstypen umgehen:

\begin{itemize}
	\item xml
	\item apache
	\item Generic-Conf
	\item IniFile
	\item PHPConstants
	\item phparray
\end{itemize}

In diesem Projekt wird die Ausgabe als PHP-Array und XML benutzt. 

Listing \ref{lst:PEARConfig} zeigt, wie simpel es ist, ein XML-Konfigurationsfile einzulesen.  

\begin{lstlisting}[caption=PEAR Config, language=PHP, label=lst:PEARConfig]
function parse($file = "inc/settings.xml") {
  
	$conf = new Config;
	$root =& $conf->parseConfig($file, 'XML');

    if (PEAR::isError($root)) {
       die('Error while reading configuration: ' . $root->getMessage());
    }
	
    return $root->toArray();
}	
\end{lstlisting}

Anschließend steht das XML-File als Assoziatives Array zur Verfügung. 

Für mehr Informationen über PEAR::Config \citep[vgl.][]{pearconfig}.


\subsection{PEAR::Log} \index{PEAR!Log} \label{anh:PEARLog}

Die Klasse Log generiert Log-Einträge. Es können entweder Log-Files erstellt werden oder die Log-Einträge in eine Datenbank geschrieben werden. Hierfür ist eine Tabelle nötig. Die Struktur sehen Sie in Listing \ref{lst:PEARLog}.

\begin{lstlisting}[caption=PEAR Log, language=SQL, label=lst:PEARLog]
CREATE TABLE log_table ( 
  id          INT NOT NULL, 
  logtime     TIMESTAMP NOT NULL, 
  ident       CHAR(16) NOT NULL, 
  priority    INT NOT NULL, 
  message     VARCHAR(200), 
  PRIMARY KEY (id) 
);
\end{lstlisting}

Dies wird auch in diesem Projekt angewendet. 
 
Listing \ref{lst:PEARLoggenerieren} zeigt, wie nun ein neuer Log-Eintrag generiert wird. 

\begin{lstlisting}[caption=PEAR Logeintrag generieren, language=PHP, label=lst:PEARLoggenerieren]
<?php
 
require_once 'DB.php';
require_once 'Log.php';

$config['conf']['DB']['type'] = 'mysql';
$config['conf']['DB']['host'] = 'localhost';
$config['conf']['DB']['user'] = 'root';
$config['conf']['DB']['pass'] = 'pass';
$config['conf']['DB']['name'] = 'dbname';


$db = &DB::connect($config['conf']['DB']['type']."://".
				   $config['conf']['DB']['user'].":".
				   $config['conf']['DB']['pass']."@".
				   $config['conf']['DB']['host']."/".
				   $config['conf']['DB']['name']
				   );				   

$conf['db'] = $db;

$logger = &Log::singleton('sql', 'log_table', 'ident', $conf);

$logger->log("Log PEAR_LOG_WARNING", PEAR_LOG_WARNING);
usleep(10);
$logger->log("Log PEAR_LOG_ALERT", PEAR_LOG_ALERT);
usleep(10);
$logger->log("Log PEAR_LOG_CRIT", PEAR_LOG_CRIT);
usleep(10);
$logger->log("Log PEAR_LOG_ERR", PEAR_LOG_ERR);
usleep(10);
$logger->setIdent("MODULE");
$logger->log("Log PEAR_LOG_WARNING", PEAR_LOG_WARNING);
usleep(10);
$logger->log("Log PEAR_LOG_NOTICE", PEAR_LOG_NOTICE);
usleep(10);
$logger->log("Log PEAR_LOG_DEBUG", PEAR_LOG_DEBUG);

?>
\end{lstlisting}

Erklärung:

\begin{description}
	\item[Zeile 3-4] DB und Log-Klassen werden eingebunden 
	\item[Zeile 6-20] Datenbankkonfiguration sowie die Verbindung zur Datenbank. Es kann auch ein bereits vorhandenes DB-Objekt benutzt werden.
	\item[Zeile 22] Es wird eine Instanz der Log-Klasse erzeugt, angebeben, dass SQL benutzt wird, also eine Datenbank, sowie der Tabellenname übergeben.
	\item[Zeile 24] Dies ist ein Beispiel eines Log-Eintrages. Übergeben werden einmal ein Text und der Error-Code. Es gibt folgende vordefinierte Error-Codes, die meistens ausreichen:
	
		\begin{description}
			\item[PEAR\_LOG\_EMERG] System ist offline oder nicht nutzbar.
			\item[PEAR\_LOG\_ALERT] Systemstabilität ist gefährdet.
			\item[PEAR\_LOG\_CRIT] Ein kritischer Fehler ist aufgetreten.
			\item[PEAR\_LOG\_ERR] Ein Fehler ist aufgetreten.
			\item[PEAR\_LOG\_WARNING] Fehlverhalten des Systems, das System bleibt wahrscheinlich funktionsfähig.
			\item[PEAR\_LOG\_NOTICE] System läuft stabil, aber etwas Auffälliges ist passiert.
			\item[PEAR\_LOG\_INFO] Information.
			\item[PEAR\_LOG\_DEBUG] Debug-Informationen.
		\end{description}
\end{description}
 
Für den normalen Gebrauch reichen diese Fehlerlevel aus, können jedoch noch angepasst bzw. erweitert werden. Es ist auch möglich, bestimmte Fehler nicht nutzbar zu machen.

Für mehr Informationen über PEAR::Log \citep[vgl.][]{pearlog}

\subsection{PEAR::DB\_QueryTool} \label{anh:pearquerytool}.

Das PEAR::DB\_QueryTool ist eine objektorientierte Abstraktion der SQL-Sprache. Mit einfachen Methoden wie \emph{setWhere()}, \emph{setOrder()}, \emph{setGroup()} etc. ist es nun einfach möglich SQL zu generieren. Es ist nicht nötig, den SQL-Text selbst zu verfassen. Das Listing \ref{lst:PEARQueryTool} zeigt ein kurzes Beispiel.

\begin{lstlisting}[caption=PEAR QueryTool, language=PHP, label=lst:PEARQueryTool]

<?php
require_once 'DB/QueryTool.php';
define('TABLE', 'MMO_TT_ATT_Bearbeiter_Ticket');
$dsn = 'dbtype://user:pass@host/dbname';

class Ticket extends DB_QueryTool
{
    var $table        = TABLE;
    var $sequenceName = TABLE;

    // Primary Key
    var $primaryCol =   'AR_TicketIdentifizierer';

    /**
	   * sets up a short name
     */
    var $tableSpec = array(
        array('name'  => TABLE, 'shortName' =>  'tt'),
        //array('name'  => TABLE_TIME, 'shortName' =>  'time'),
    );
}


$ticket = new Ticket($dsn);

$ticket->reset();     // reset the query-builder, so no where, order, etc. are set
$res = $ticket->get(3);
echo "<pre>"; print_r($res); echo "</pre>";

$ticket->reset();     // reset the query-builder, so no where, order, etc. are set
$res = $ticket->getAll(0, 10);
echo "<pre>"; print_r($res); echo "</pre>";

$ticket->reset();
$ticket->setWhere('AR_TicketIdentifizierer="00000224"');
$ticket->setOrder('AR_TicketIdentifizierer');
$res = $ticket->getAll();
echo "<pre>"; print_r($res); echo "</pre>";

?>

\end{lstlisting}

Erklärung:
\begin{description}
	\item[Zeile 3] Inkludiert die QueryTool-Klasse.
	\item[Zeile 7-22] Ticketklasse wird von DB\_QueryTool abgeleitet. \$table, \$sequenceName und \$primaryCol müssen angegeben werden. Dies sind der Tabellenname, der Sequenzname, falls eine eigene Sequenz verwendet werden soll und die Tabelle kein AutoIncrement verwendet und der Name der Primary Key Spalte. 
	\item[Zeile 25] Eine neue Instanz der Klasse wird erzeugt. Diese bekommt den DNS, Data Source Name, übergeben.
	\item[Zeile 27] Der Query-Builder wird zurückgesetzt, also Where- oder Order-Bedingungen werden gelöscht.  
	\item[Zeile 28] Die Methode get(3) gibt den Datensatz mit der PrimaryID 3 zurück.
	\item[Zeile 32] In diesem Falle werden die ersten 10 Einträge zurückgegeben (0-10)
	\item[Zeile 36-37] Hier wird eine Where- und eine Order-Bedingung gesetzt.
\end{description}

\glossary{name={DNS}, description={Data Source Name. Eine Bezeichnung die PEAR für den Connectionstring benutzt.},
}

Für mehr Informationen über PEAR::DB\_QueryTool \citep[vgl.][]{pearquery}

\subsection{PEAR::HTML\_Template\_Sigma}

Die PEAR-Klasse HTML\_Template\_Sigma ist eine von mehreren Template-Engines, welche die PEAR-Bibliothek zur Verfügung stellt. HTML\_Template\_Sigma ist eine der schnellsten, weshalb sie auch ausgewählt wurde. 

Der Sinn einer Template-Engine liegt darin, dass der Code für die Datenbankanbindung sowie für die Logik vom HTML-Code für die Anzeige getrennt wird. 

Dies wird dadurch erreicht, dass ein sogenanntes Template, also eine Vorlage in HTML, angelegt wird und von der Template Engine geladen und dann bestimmte Platzhalter dynamisch zur Laufzeit durch Inhalt ersetzt werden. 

Das folgende Listing \ref{lst:PEARTemplateEngineCode} gibt ein kurzes Beispiel, wie eine Kombination aus QueryTool und Template-Engine aussehen kann.

\begin{lstlisting}[caption=PEAR Template Engine PHP Code, language=PHP, label=lst:PEARTemplateEngineCode]

<?php
require_once 'DB/QueryTool.php';

require_once 'HTML/Template/Sigma.php';

define('TABLE', 'MMO_TT_ATT_Bearbeiter_Ticket');
$dsn = 'dbtype://user:pass@host/dbname';

class Ticket extends DB_QueryTool
{
    var $table        = TABLE;
    var $sequenceName = TABLE;

    // Primary Key
    var $primaryCol =   'AR_TicketIdentifizierer';
    /**
	 * sets up a short name
     */
    var $tableSpec = array(
        array('name'  => TABLE, 'shortName' =>  'tt'),
    );
}

//instanciate an object of the Car class
$ticket = new Ticket($dsn);

// get the first 10 
$ticket->reset();     // reset the query-builder, so no where, order, etc. are set
$res = $ticket->getAll(0, 10);

$tpl =& new HTML_Template_Sigma('.');

$tpl->loadTemplateFile('table.html');

foreach ($res as $name) {
    // assign data
    $tpl->setVariable(array(
        'id'  => $name[AR_TicketIdentifizierer],
        'ticket' => $name[GT_Ticketnummer]
    ));
    // process the block
    $tpl->parse('table_row');
}
// print out the output
$tpl->show();

?>
\end{lstlisting}

\textbf{Zur Erklärung:}
\begin{description}
	\item[Zeile 3] Bindet die Template Engine Klasse ein.
	\item[Zeile 10-23] Ableitung von der QueryTool Klasse. Siehe QueryTool.
	\item[Zeile 32] Neue Instanz der HTML\_Template\_Sigma-Klasse wird erzeugt. 
	\item[Zeile 36-44] Die Daten aus dem Ergebnis des Querytools werden durchlaufen und variablen zugewiesen. In jedem Durchlauf wird die Zeile table\_row geparst. 
	\item[Zeile 46] Parst das gesamte Template und zeigt es an. 
\end{description}

Nachfolgendes Listing \ref{lst:PEARTemplateEngineHTML} zeigt den dazugehörigen HTML-Code des Templates.

\begin{lstlisting}[caption=PEAR Template Engine HTML Code, language=HTML, label=lst:PEARTemplateEngineHTML]
<html>
<body>
<table cellpadding="2" cellspacing="0" border="1">
<!-- BEGIN table_row -->
    <tr>
        <td>{id}</td>
        <td>{ticket}</td>
    </tr>
<!-- END table_row -->
</table>
</body>
\end{lstlisting}

\textbf{Zur Erklärung:}
\begin{description}
	\item[Zeile 52] Start des Abschnitts table\_row. 
	\item[Zeile 54-55] Beinhaltet die Variablen (Platzhalter) namens {id} und {ticket}. Diese werden ersetzt. 
	\item[Zeile 57] Ende des Abschnitts table\_row. 
\end{description}


\subsection{PEAR::SOAP} \index{PEAR!SOAP}

Dieses Paket ermöglicht es, mit PHP einen Webservice zu erstellen. Ein Webservice besteht aus drei Komponenten: Ein Server, ein Verbraucher und ein Verzeichnisdienst. Da unser Webservice nicht in ein Verzeichnis eingetragen wird, wo sich der Verbraucher normalerweise die Daten des Webservices herunterlädt, wird nachfolgend der Server inklusive der WSDL beschrieben und ein Client respektive ein Verbraucher, zu Testzwecken erstellt. 

Das Listing \ref{lst:PEARSOAPWebservice} zeigt einen Webservice-Server. Dies ist ein einfaches Beispiel.

\begin{lstlisting}[caption=PEAR SOAP Webservice, language=PHP, label=lst:PEARSOAPWebservice]
<?php
require_once('SOAP/Server.php');
require_once('SOAP/Disco.php');

class Sales
{
     var $__dispatch_map = array();

     function Sales() {
         // Define the signature of the dispatch map on the Web services method
         // Necessary for WSDL creation
         $this->__dispatch_map['onsale'] = array(
		           'in'  => array('low'   => 'integer', 'high' => 'integer'),
                   'out' => array('sales' => 'string[]'),
                   );
     }

     function onsale($low, $high)  {
	    $rval = array();
        if ($low[0] < 1) {
		   $rval[] = "This is smaller 1";
		   $rval[] = "We have some bargains, but not at those prices!";
		   return $rval;

       } else if ( $high < 100 ) {
           $rval[] = "This is smaller 100";
		    $rval[] = "We have a few gadgets which fit your price range,
                   visit our site for more details and pictures!";
		   return $rval;
       } else {
	       $rval[] = "This is smaller 100";
		   $rval[] = "Thats more than spare change, have you considered
                   donating some of it to an Open-Source project ? ";
		   return $rval;
       }
   }
}

$server = new SOAP_Server();
$webservice = new Sales();
$server->addObjectMap($webservice, 'http://schemas.xmlsoap.org/soap/envelope/');

if (isset($_SERVER['REQUEST_METHOD'])  && $_SERVER['REQUEST_METHOD']=='POST') {
     $server->service($HTTP_RAW_POST_DATA);
} else {
     // Create the DISCO server
     $disco = new SOAP_DISCO_Server($server,'Sales');
     header("Content-type: text/xml");
     if (isset($_SERVER['QUERY_STRING']) &&
         strcasecmp($_SERVER['QUERY_STRING'],'wsdl') == 0) {
         echo $disco->getWSDL();
     } else {
         echo $disco->getDISCO();
     }
}
exit;
?>
\end{lstlisting}

\begin{description}
	\item[Zeile 2-3] Inkludiert die PEAR-Klassen für den Server und den Disco-Server. DISCO steht für Discovery of Web Services und ist ein Verzeichnisdienst für Web Services. 
	\item[Zeile 7-16] Deklariert die dispatch-map und deklariert die In- und Out-Parameter des Webservices im Konstruktor der Klasse Sales.
	\item[Zeile 18-37] Die Methode, die als Webservice angeboten wird. In diesem Fall empfängt sie zwei Parameter und liefert eine String-Vektor zurück. 
	\item[Zeile 39] Erzeugt das SOAP-Server Objekt.
	\item[Zeile 40] Erzeugt ein neues Objekt der Sales-Klasse.
	\item[Zeile 41] Fügt dem SOAP-Server die Klasse Sales hinzu.
	\item[Zeile 43-55] Falls der User im Querystring ?wsdl angegeben hat, so wird die WSDL zurückgeliefert. Werden Daten per POST übermittelt, so wird der Webservice gestartet. 
\end{description}

\glossary{name={DISCO}, description={Discovery of Web Services. Ist für die Bekanntmachung eines Webservices zuständig. Ein DISCO-File enthält den URI des Webservices. Die URI zeigt üblicherweise auf die WSDL des Webservices.},
}
\index{DISCO}

