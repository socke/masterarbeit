\setchapterpreamble[u]{%
\dictum[Douglas Adams]{A common mistake that people make when trying to design something completely foolproof is to underestimate the ingenuity of complete fools. \dots}}
\chapter{System- und Softwareentwurf} \index{System- und Softwareentwurf}\label{kap:systemundsoftwarentwurf}


Dieses Kapitel beschreibt den System- und Softwareentwurf sowie die Auswahl der Umgebung, Plattform, Software, Programmiersprache und Frameworks.

\section{Auswahlprozess}

Teil der Aufgabe der Arbeit ist es, für das System im Rahmen der nichtfunktionalen Anforderungen eine geeignete Umgebung zu schaffen. Dafür sind einige Entscheidungen zu treffen. 

\subsection{Webservice}\index{Webservice}
Wenn von Webservices gesprochen wird, dann werden meistens \gls{SOAP}-basierte Webservices gemeint. Allerdings gibt es die sogenannten \gls{SOAP}-basierten Webservices als auch die RESTful Webservices. Anforderung ist es ein Web Service zu implementieren. Dazu muss entschieden werden, ob ein \gls{SOAP}-basierter oder RESTful Webservice implementiert werden soll. \index{REST@\textbf{REST}} \index{REST!RESTful}

\subsubsection{Definition}

\begin{quotation}
\enquote{Web services provide the means to integrate disparate systems and expose reusable business functions over HTTP. They either leverage HTTP as a simple transport over which data is carried (e.g., SOAP/\gls{WSDL} services) or use it as a cimplete application protocol that defines the semantics for service behavior (e.g. RESTful services) \citep[S. 2][]{robinsonService}}	
\end{quotation}

\subsubsection{SOAP/WSDL Webservice}\index{SOAP}\index{WSDL}\index{Webservice}
Frau Janssen hat in ihrer Abschlussarbeit einen Webservice nach ISO 29002-20 mittels einem SOAP/WSDL Webservice implementiert \citep[vgl.][]{janssen}. Die ISO 29002-20 verweist in Annex-B auf entsprechende WSDL-Definitionen. 
Ich möchte an dieser Stelle darauf verzichten, die Einzelheiten eines SOAP/WSDL Webservice zu erläutern und verweise auf Frau Janßens Abschlussarbeit \citep[vgl.][Kap. 3]{janssen}. 

Es sei an dieser Stelle kurz erwähnt, dass Webservices auf SOAP/WSDL basierend ein W3C\footnote{World Wide Web Consortium - http://www.w3.org} Standard sind. 

\subsubsection{RESTful Webservice}\index{RESTful Webservice}\index{REST@\textbf{REST}} \index{REST!RESTful} \index{REST!RESTful Webservice}
RESTful Webservices sind per se kein Standard sondern eher ein Programmierparadigma respektive ein Architekturmuster. 
\todotext{Weiter ausführen und Quelle angeben}

\subsubsection{Fazit}
Es wurde ein RESTful Webservice ausgewählt. Die Gründe stellen sich wie folgt dar:

\begin{description}
\item[Einfache Implementierung] Da RESTful Webservices auf dem HTTP Protokoll basiert und ferner sehr gute geeignete Frameworks für Java vorhanden sind, siehe \autoref{kap:bibliotheken_und_frameworks}, stellt sich für Web Entwickler die Implementierung als einfach heraus.
\item[Payload XML] Der Payload des Anfrage Queries wird als XML angegeben (siehe \autoref{fig:datenfluesse}. Als mögliche Übertragung wird email angegeben. Das bedeutet für die Anforderung, das ein Web Service  implementiert werden soll, dass die XML-Repräsentation des Queries als Payload mittels XML zu übertragen ist. Folglich könnte sowohl SOAP als auch REST benutzt werden. Voraussetzung ist eine definierten Schnittstelle, welche lediglich ein XML als Payload akzeptiert. 
\item[Kein Vorteil bei SOAP] Somit hat SOAP keinen Vorteil gegenüber REST. Der Vorteil würde darin bestehen, wenn SOAP selbst die Operationen anbietet (definiert in der WSDL). Das hat den Nachteil, dass die wohlgeformte vorgegebenen Schemata query.xsd, in der Form nicht genutzt werden können. Es muss somit eine Einbindung in SOAP erfolgen. 
\item[Vorteil des Payloads] Der klare Vorteil bei der Variante eine Query XML-Datei gemäß query.xsd Schema des Standards als Payload zu versenden ist der, dass eine Validierungsprüfung der XML gegen vorhandene definierte Regeln des Schemas erfolgen kann (z.B. gültige IRDI), ferner können aus dem Schema passende Modellklassen zur Verarbeitung und Speicherung der Query-Daten in der Applikation generiert werden. Mehr Informationen in Kapitel \todotext{Kapitel raussuchen und verlinken} (generierung mit jax). 
\end{description}

\subsection{Plattform} \index{Apache Tomcat} \label{sec:plattform}
Als Laufzeitumgebung wurde der Apache Tomcat Server in der Version 7 ausgewählt. Das ist ein üblicher Web Container (Web Server), welcher mit entsprechenden Frameworks bzw. Bibliotheken sowohl \gls{SOAP} als auch RESTful Web Services anbieten kann. 
\todotext{Kapitel weiter ausführen und Quellen angeben}

\subsection{Bibilotheken und Frameworks} \index{Bibilotheken und Frameworks}\label{bibliotheken_und_frameworks}
\begin{description}

\item[Jersey] Framework zur Erstellung von RESTful Web Services \index{Jersey}\gls{Jersey}
\item[JSF2.0] Komponentenbasiertes Web Framework zur Erstellung von Benutzeroberflächen \index{JSF2.0}
\item[Spring] Dependency Injection Framework. Bietet darüber hinaus noch weitere Komponenten an. Ausgewählt wurde unter anderem \gls{Spring} JDBC und \gls{Spring} Data Oracle, welche einfacheren Zugriff auf relationale Datenbanken sowie auf Prozeduren von relationalen Datenbanken ermöglicht. Mehr Details zur Implementierung in Kapitel \todotext{Kapitel angeben}. \index{Spring} 
    
\end{description}

\todotext{Eine detaillierte Erklärung der Frameworks nötig, Erläuterung des Nutzens und weshalb diese ausgesucht wurden. Ggfs in Anhang}

\subsection{Programmiersprache}
Vorgegeben ist die Umsetzung eines Webservices. Diese lassen sich in fast allen aktuellen Programmiersprachen entwickeln, folglich kann prinzipiell jede Sprache ausgewählt werden die Webservices anbieten kann.  

Es wurde die Sprache Java gewählt, da diese zum einen in der aktuellen Industrie stark verbreitet und zum anderen der Autor dieser Arbeit seit vielen Jahren damit vertraut ist. Ferner besteht hier eine Abhängigkeit zur Auswahl der Plattform gleichsam dem Web Kontainer, siehe \autoref{sec:plattform}. 

Ein weiterer Aspekt ist, dass Software welche mit Java entwickelt wurde im Prinzip auf jedem Betriebssystem lauffähig, und somit portierbar ist. Dies ist zwar keine Anforderung des Projektes, aber ermöglicht die Arbeit und Entwicklung in beliebigen Systemen. 

\section{Softwaredesign und Architektur}

\subsection{Bausteinsicht}\index{Software-Bausteine}
\begin{quotation}
Die Bausteinsicht bildet die Aufgaben des Systems auf Software-Bausteine oder -Komponenten ab.
 \citep[S. 98ff][]{starke}	
\end{quotation}

Es soll mit Hilfe dieser Sicht ein Überblick über den Aufbau des Systems und den Abhängigkeiten der einzelnen Komponenten geschaffen werden. Dazu wird das System im top-down Ansatz aufgezeigt und verfeinert. 

\subsubsection{Level 0 - Systemüberblick mit angrenzenden Systemen} 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\textwidth]{images/bausteinsicht_plib_level0.png}
	\caption{Bausteinsicht Level 0}
	\label{fig:bausteinsicht_level0}
\end{figure}

\paragraph{Klient}

Der Klient stellt den Nutzer des Query Services dar. Er erzeugt das XML File, welches als Query an den Service geschickt wird. Der Transport erfolgt über das HTTP Protokoll.  

\paragraph{Applikationsserver}

Der Applikationsserver ist der Hauptbaustein. Dieser Baustein enthält alle entwickelten Komponenten. Sichtbar von außen ist der QueryService, dieser Service ist ein REST WebService und nimmt XML-Dateien als Payload eines POST Requests entgegen. 

\subsubsection{Level 1 - Plib characteristic query} 

Die Bausteinsicht Level 1 zeigt alle Komponenten des entwickelten Systems auf und deutet die externen Schnittstellen an. Mittels <<use>> Beziehungen erkennt man die Abhängigkeiten der einzelnen Komponenten. 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.98\textwidth]{images/bausteinsicht_plib_level1.png}
	\caption{Bausteinsicht - Level 1}
	\label{fig:bausteinsicht_level1}
\end{figure}

\begin{description}
\item[QueryService] Der Zweck dieser Komponente ist das entgegennehmen des Requests (Query-XML File), das Weiterleiten an die entsprechenden Weiterverarbeitenden Komponenten und letztlich das Zurücksenden der Rückantwort (Katalog-XML).
\item[Data Access] Diese technische Komponente beinhaltet die Zugriffsschicht auf die externe Datenbankschnittstelle und bietet entsprechend vereinfachte Abfrageschnittstellen für die anderen Komponenten an. 
\item[Marshaller] Eine weitere technische Komponente, diese ist für das Einlesen und Validieren der eingegangenen Query-XML Datei verantwortlich. Ferner transformiert diese Komponente die Informationen aus der Query-XML nach Validierung in das im System benutze Datenmodell aus der Komponente XMLData.
\item[XMLData] Beinhaltet das Datenmodell des Systems. Sowohl die eingehenden Query-XML Daten, als auch die ausgehenden Katalog-XML Daten werden intern in ein entsprechendes Model zur Verarbeitung abgelegt, so dass darauf gearbeitet werden kann.  
\item[Analyser] \todotext{Erläuterung fehlt}
\item[Handler] \todotext{Erläuterung fehlt}
\end{description}

\subsubsection{Level 2 - Whiteboxansicht - Komponente XMLData} 

Die Komponente XMLData beinhaltet alle Datenmodelle für die beiden Hauptkonzepte \enquote{Query for characteristic data} nach 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.82\textwidth]{images/bausteinsicht_plib_level2_xmldata.png}
	\caption{Bausteinsicht - Level 2 - Komponente XMLData}
	\label{fig:bausteinsicht_level2_xmldata}
\end{figure}

\begin{description}
\item[Query] Diese Komponente beinhaltet das Datenmodell des Queries nach ISO/TS 29002-31. 
\item[Catalogue] Diese Komponente beinhaltet das Datenmodell des Kataloges nach ISO/TS 29002-10. 
\item[Basic] Diese Komponente beinhaltet das Datenmodell von Basistypen nach ISO/TS 29002-4.
\item[Value] Diese Komponente beinhaltet das Datenmodell der Wertetypen nach ISO/TS 29002-10.
\item[Identifier] Diese Komponente beinhaltet das Datenmodell für Identifier (IRDI) nach ISO/TS 29002-5. 
\end{description}

